---
phase: 01-css-token-engine
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/main/java/com/dwc/laf/css/CssTokenParser.java
  - src/test/java/com/dwc/laf/css/CssTokenParserTest.java
autonomous: true

must_haves:
  truths:
    - "Parser extracts --custom-property declarations from :root blocks"
    - "Parser extracts --custom-property declarations from component selectors like .dwc-button"
    - "All tokens flatten into a single map with component-level overriding :root"
    - "Parser handles single CSS file input (not directory scanning)"
    - "Malformed CSS values are skipped with JUL warning, rest of file continues parsing"
  artifacts:
    - path: "src/main/java/com/dwc/laf/css/CssTokenParser.java"
      provides: "CSS custom property extraction from CSS text"
      exports: ["parse"]
      contains: "class CssTokenParser"
    - path: "src/test/java/com/dwc/laf/css/CssTokenParserTest.java"
      provides: "Tests for CSS token extraction"
      contains: "@Test"
  key_links:
    - from: "CssTokenParser.java"
      to: "Map<String, String>"
      via: "Returns raw token map (property name -> raw value string)"
      pattern: "Map<String,\\s*String>"
---

<objective>
Build the CSS token parser that extracts custom property declarations from CSS text into a raw string map.

Purpose: This is Pass 1 of the two-pass architecture. It reads CSS text and extracts all `--property: value` declarations from `:root` and component-level selectors, flattening into a single map where component-level values override `:root` values for the same property name.
Output: CssTokenParser.java with parse() method and comprehensive tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-css-token-engine/01-CONTEXT.md
@.planning/phases/01-css-token-engine/01-RESEARCH.md
@.planning/phases/01-css-token-engine/01-01-SUMMARY.md
</context>

<feature>
  <name>CSS Token Parser - Custom Property Extraction</name>
  <files>
    src/main/java/com/dwc/laf/css/CssTokenParser.java
    src/test/java/com/dwc/laf/css/CssTokenParserTest.java
  </files>
  <behavior>
    Parse CSS text and extract all custom property declarations into a Map of String to String.

    Input: CSS text as a String
    Output: Map where key = property name (e.g., "--dwc-color-primary-h"), value = raw value string (e.g., "211")

    Cases:
    - `:root { --color: red; }` -> {"--color": "red"}
    - `:root { --a: 1; } .comp { --a: 2; }` -> {"--a": "2"} (component overrides :root)
    - `:root { --a: 1; --b: var(--a); }` -> {"--a": "1", "--b": "var(--a)"} (var() NOT resolved here, just extracted raw)
    - `:root { --font: -apple-system, sans-serif; }` -> {"--font": "-apple-system, sans-serif"} (commas in value preserved)
    - `:root { --shadow: 0 2px 4px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.05); }` -> value string preserves multi-part values
    - CSS comments stripped: `/* comment */ :root { --a: 1; }` -> {"--a": "1"}
    - Non-custom properties ignored: `:root { color: red; --custom: blue; }` -> {"--custom": "blue"}
    - Multiple selector blocks: `:root { --a: 1; } :host { --b: 2; } .dwc-button { --c: 3; }` -> all three extracted
    - Empty input: "" -> empty map
    - Malformed: `:root { --broken }` -> skipped with warning, map empty
    - Multi-line values (shadows): value spans lines until semicolon -> captured as single trimmed string
    - Whitespace handling: values trimmed, internal whitespace normalized

    Implementation approach: Hand-written character-by-character parser (not regex). Walk the CSS text:
    1. Strip CSS block comments (/* ... */)
    2. Find selector blocks by matching `{` and `}` with nesting awareness
    3. Within each block, find declarations: scan for `--` at declaration start, read property name until `:`, read value until `;` or `}`
    4. Track selector context (:root gets lower priority, anything else overrides)
    5. Build LinkedHashMap preserving insertion order; :root entries first, then component entries overwrite

    Error handling:
    - Malformed declarations (no colon, no value): log via java.util.logging, skip, continue
    - Unmatched braces: log warning, attempt best-effort parsing
    - Null/empty input: return empty map
  </behavior>
  <implementation>
    CssTokenParser as a final class with:
    - `public static Map<String, String> parse(String cssText)` -- main entry point
    - Private helper methods for comment stripping, block extraction, declaration parsing
    - Use java.util.logging.Logger for warnings (per user decision: JUL only)
    - Return Collections.unmodifiableMap() wrapping the result

    Test-first approach: Write tests covering all cases above BEFORE implementing. Run tests (RED). Then implement to pass (GREEN). Refactor if needed.
  </implementation>
</feature>

<verification>
- `mvn test -pl . -Dtest=CssTokenParserTest` -- all tests pass
- Parser handles the bundled default-light.css: returns 200+ entries
- Parser handles test-tokens.css: returns all expected entries
- Component-level properties override :root properties for same name
</verification>

<success_criteria>
- CssTokenParser.parse() extracts custom properties from :root and component selectors
- Flattening works: component-level overrides :root for same property name
- Multi-line values (shadows) captured correctly
- Malformed entries skipped with JUL warning, parsing continues
- All test cases pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-css-token-engine/01-02-SUMMARY.md`
</output>
