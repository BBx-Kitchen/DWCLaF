---
phase: 03-shared-painting-utilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/com/dwc/laf/painting/PaintUtils.java
  - src/main/java/com/dwc/laf/painting/HiDpiUtils.java
  - src/main/java/com/dwc/laf/painting/StateColorResolver.java
  - src/test/java/com/dwc/laf/painting/PaintUtilsTest.java
  - src/test/java/com/dwc/laf/painting/HiDpiUtilsTest.java
  - src/test/java/com/dwc/laf/painting/StateColorResolverTest.java
autonomous: true

must_haves:
  truths:
    - "Antialiasing setup saves and restores Graphics2D rendering hints without corruption"
    - "Rounded shapes degenerate correctly: arc=0 produces Rectangle2D, arc>=min(w,h) on square produces Ellipse2D"
    - "Outline painting via even-odd fill produces pixel-exact rings without stroke bleed"
    - "HiDPI scale factor is read from Graphics2D transform, not system properties"
    - "State color resolver returns disabled color when component is disabled, pressed when pressed, hover when rollover, focused when focused, enabled otherwise"
  artifacts:
    - path: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      provides: "Antialiasing setup/restore, rounded shape factory, outline painting, rounded background fill"
      exports: ["setupPaintingHints", "restorePaintingHints", "createRoundedShape", "paintOutline", "paintRoundedBackground"]
    - path: "src/main/java/com/dwc/laf/painting/HiDpiUtils.java"
      provides: "HiDPI scale detection, device-resolution BufferedImage creation"
      exports: ["getScaleFactor", "createHiDpiImage"]
    - path: "src/main/java/com/dwc/laf/painting/StateColorResolver.java"
      provides: "Component state to color resolution with priority chain"
      exports: ["resolve", "paintWithOpacity"]
    - path: "src/test/java/com/dwc/laf/painting/PaintUtilsTest.java"
      provides: "Tests for shape creation, hint save/restore, outline geometry"
    - path: "src/test/java/com/dwc/laf/painting/HiDpiUtilsTest.java"
      provides: "Tests for scale factor extraction and image sizing"
    - path: "src/test/java/com/dwc/laf/painting/StateColorResolverTest.java"
      provides: "Tests for state priority chain and opacity painting"
  key_links:
    - from: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      to: "java.awt.geom.RoundRectangle2D.Float"
      via: "createRoundedShape returns Shape"
      pattern: "RoundRectangle2D\\.Float"
    - from: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      to: "java.awt.geom.Path2D"
      via: "paintOutline uses WIND_EVEN_ODD"
      pattern: "Path2D\\.WIND_EVEN_ODD"
    - from: "src/main/java/com/dwc/laf/painting/StateColorResolver.java"
      to: "javax.swing.AbstractButton"
      via: "instanceof check for ButtonModel state"
      pattern: "instanceof AbstractButton"
---

<objective>
Build the three foundation painting utilities (PaintUtils, HiDpiUtils, StateColorResolver) that all future component delegates will consume for antialiased rendering, HiDPI awareness, and state-driven color selection.

Purpose: These utilities establish the shared painting contract that Phases 4-7 component delegates depend on. Without them, every delegate would duplicate antialiasing setup, shape creation, and state color logic.
Output: 3 production classes + 3 test classes in `com.dwc.laf.painting` package.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-shared-painting-utilities/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: PaintUtils - antialiasing, rounded shapes, outlines, and background fill</name>
  <files>
    src/main/java/com/dwc/laf/painting/PaintUtils.java
    src/test/java/com/dwc/laf/painting/PaintUtilsTest.java
  </files>
  <action>
Create `com.dwc.laf.painting.PaintUtils` as a final class with private constructor (non-instantiable utility).

Implement these static methods:

1. `setupPaintingHints(Graphics2D g)` -> `Object[]` — Save current KEY_ANTIALIASING and KEY_STROKE_CONTROL hints from g, then set KEY_ANTIALIASING=VALUE_ANTIALIAS_ON and KEY_STROKE_CONTROL=VALUE_STROKE_NORMALIZE. Return the saved hints array (length 2). Handle null saved hints gracefully.

2. `restorePaintingHints(Graphics2D g, Object[] saved)` — Restore hints saved by setupPaintingHints. Only call setRenderingHint if the saved value is non-null.

3. `createRoundedShape(float x, float y, float w, float h, float arc)` -> `Shape` — Smart shape factory with degeneration:
   - arc <= 0: return `new Rectangle2D.Float(x, y, w, h)`
   - Clamp arc to `Math.min(arc, Math.min(w, h))`
   - If clamped arc >= Math.min(w, h) AND w == h: return `new Ellipse2D.Float(x, y, w, h)`
   - Otherwise: return `new RoundRectangle2D.Float(x, y, w, h, clampedArc, clampedArc)`

4. `paintOutline(Graphics2D g, float x, float y, float w, float h, float lineWidth, float arc)` — Outline via even-odd fill rule. Create Path2D.Float with WIND_EVEN_ODD. Append outer shape from createRoundedShape(x, y, w, h, arc). Calculate innerArc = Math.max(arc - lineWidth, 0). Append inner shape from createRoundedShape(x+lineWidth, y+lineWidth, w-2*lineWidth, h-2*lineWidth, innerArc). Call g.fill(path). Do NOT manage hints here (caller is responsible).

5. `paintRoundedBackground(Graphics2D g, float x, float y, float w, float h, float arc, Color bg)` — If bg is null, return. Call setupPaintingHints, setColor, fill(createRoundedShape), restorePaintingHints.

Tests (PaintUtilsTest.java):
- testSetupAndRestoreHints: create BufferedImage Graphics2D, verify hints change and restore
- testCreateRoundedShape_zeroArc: verify returns Rectangle2D.Float instance
- testCreateRoundedShape_normalArc: verify returns RoundRectangle2D.Float instance
- testCreateRoundedShape_circleDegeneration: w==h, arc >= w, verify returns Ellipse2D.Float instance
- testCreateRoundedShape_arcClamping: arc > w, verify arc is clamped (check shape bounds)
- testPaintOutline_createsEvenOddPath: verify painting does not throw, produces non-null result on BufferedImage
- testPaintRoundedBackground_nullColor: verify no exception and no painting when bg is null
- testPaintRoundedBackground_paintsPixels: verify pixels are painted on BufferedImage with non-null color

Use BufferedImage(TYPE_INT_ARGB) for test Graphics2D instances.
  </action>
  <verify>cd /Users/beff/_lab/dwclaf && mvn test -pl . -Dtest="com.dwc.laf.painting.PaintUtilsTest" -q</verify>
  <done>PaintUtils has 5 static methods. All shape degeneration cases tested. Hint save/restore verified. Outline uses WIND_EVEN_ODD. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: HiDpiUtils - scale detection and device-resolution image creation</name>
  <files>
    src/main/java/com/dwc/laf/painting/HiDpiUtils.java
    src/test/java/com/dwc/laf/painting/HiDpiUtilsTest.java
  </files>
  <action>
Create `com.dwc.laf.painting.HiDpiUtils` as a final class with private constructor.

Implement these static methods:

1. `getScaleFactor(Graphics2D g)` -> `float` — Read g.getTransform().getScaleX() and cast to float. Do NOT use system properties or Toolkit.getScreenResolution(). If g is null, return 1.0f.

2. `createHiDpiImage(Graphics2D g, int logicalWidth, int logicalHeight)` -> `BufferedImage` — Get scale factor from g. Calculate device dimensions: Math.round(logicalWidth * scale), Math.round(logicalHeight * scale). Return new BufferedImage(deviceWidth, deviceHeight, TYPE_INT_ARGB). If logicalWidth or logicalHeight <= 0, return a 1x1 TYPE_INT_ARGB image (safety floor).

Tests (HiDpiUtilsTest.java):
- testGetScaleFactor_defaultTransform: create BufferedImage Graphics2D (default 1x), verify returns 1.0f
- testGetScaleFactor_scaled: create Graphics2D, apply AffineTransform.getScaleInstance(2.0, 2.0), verify returns 2.0f
- testGetScaleFactor_nullGraphics: verify returns 1.0f
- testCreateHiDpiImage_1x: verify image dimensions equal logical dimensions at 1x scale
- testCreateHiDpiImage_2x: apply 2x scale transform, verify image dimensions are doubled
- testCreateHiDpiImage_typeArgb: verify returned image type is TYPE_INT_ARGB
- testCreateHiDpiImage_zeroDimension: verify returns 1x1 image for zero/negative dimensions
  </action>
  <verify>cd /Users/beff/_lab/dwclaf && mvn test -pl . -Dtest="com.dwc.laf.painting.HiDpiUtilsTest" -q</verify>
  <done>HiDpiUtils reads scale from Graphics2D transform (not system props). Image creation respects scale factor. All 7 tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: StateColorResolver - component state priority chain and opacity painting</name>
  <files>
    src/main/java/com/dwc/laf/painting/StateColorResolver.java
    src/test/java/com/dwc/laf/painting/StateColorResolverTest.java
  </files>
  <action>
Create `com.dwc.laf.painting.StateColorResolver` as a final class with private constructor.

Implement these static methods:

1. `resolve(Component c, Color enabled, Color disabled, Color focused, Color hover, Color pressed)` -> `Color` — Priority chain:
   - If !c.isEnabled(): return coalesce(disabled, enabled)
   - If c instanceof AbstractButton ab: check ab.getModel().isPressed() -> coalesce(pressed, enabled); check ab.getModel().isRollover() -> coalesce(hover, enabled)
   - If c.hasFocus(): return coalesce(focused, enabled)
   - Return enabled
   Note: For pressed, check both isArmed() AND isPressed() on ButtonModel (FlatLaf pattern). isArmed() means mouse is still within button bounds while pressed.

2. `coalesce(Color primary, Color fallback)` -> `Color` — private static. Return primary if non-null, else fallback.

3. `paintWithOpacity(Graphics2D g, float opacity, Runnable paintAction)` -> void — Save g.getComposite(), set AlphaComposite.getInstance(SRC_OVER, clamp opacity to 0.0-1.0), run paintAction, restore old composite. Use Math.max(0f, Math.min(1f, opacity)) to clamp.

Tests (StateColorResolverTest.java):
- Use JButton for AbstractButton tests, JLabel/JPanel for non-button tests.
- testResolve_disabledReturnsDisabledColor: create disabled JButton, verify disabled color returned
- testResolve_disabledFallsBackToEnabled: create disabled JButton, pass null for disabled, verify enabled color returned
- testResolve_pressedReturnsPressedColor: create JButton, set model armed+pressed, verify pressed color
- testResolve_hoverReturnsHoverColor: create JButton, set model rollover, verify hover color
- testResolve_focusedReturnsFocusedColor: use a component that reports hasFocus()=true (mock or override), verify focused color. Note: hasFocus() requires the component to actually have focus in a window; for testing, create a subclass of JPanel that overrides hasFocus() to return true.
- testResolve_enabledReturnsEnabledColor: enabled JButton, no special state, verify enabled color
- testResolve_priorityDisabledOverPressed: disabled + pressed JButton, verify disabled wins
- testResolve_priorityPressedOverHover: armed+pressed + rollover JButton, verify pressed wins
- testPaintWithOpacity_changesComposite: paint on BufferedImage with opacity 0.5, verify painted pixels have reduced alpha
- testPaintWithOpacity_restoresComposite: verify composite is restored after painting
- testPaintWithOpacity_clampsValues: verify opacity > 1.0 is clamped to 1.0, opacity < 0.0 clamped to 0.0
  </action>
  <verify>cd /Users/beff/_lab/dwclaf && mvn test -pl . -Dtest="com.dwc.laf.painting.StateColorResolverTest" -q</verify>
  <done>StateColorResolver implements disabled>pressed>hover>focused>enabled priority chain. paintWithOpacity saves/restores composite. All 11 tests pass.</done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:
```
cd /Users/beff/_lab/dwclaf && mvn test -q
```
All existing 265 tests plus new painting utility tests must pass.

Verify the painting package exists:
```
ls src/main/java/com/dwc/laf/painting/
```
Should list: PaintUtils.java, HiDpiUtils.java, StateColorResolver.java

Verify test classes exist:
```
ls src/test/java/com/dwc/laf/painting/
```
Should list: PaintUtilsTest.java, HiDpiUtilsTest.java, StateColorResolverTest.java
</verification>

<success_criteria>
- PaintUtils.setupPaintingHints/restorePaintingHints correctly saves and restores Graphics2D state
- PaintUtils.createRoundedShape degenerates: arc=0 -> Rectangle2D, arc>=min(w,h) on square -> Ellipse2D, else -> RoundRectangle2D.Float
- PaintUtils.paintOutline uses Path2D.WIND_EVEN_ODD for pixel-exact outlines
- HiDpiUtils.getScaleFactor reads from Graphics2D transform, never system properties
- HiDpiUtils.createHiDpiImage creates TYPE_INT_ARGB at device resolution
- StateColorResolver.resolve follows disabled>pressed>hover>focused>enabled priority
- StateColorResolver.paintWithOpacity saves/restores composite correctly
- All new tests pass, all existing 265 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-shared-painting-utilities/03-01-SUMMARY.md`
</output>
