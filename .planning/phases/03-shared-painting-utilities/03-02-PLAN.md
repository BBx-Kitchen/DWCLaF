---
phase: 03-shared-painting-utilities
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/main/java/com/dwc/laf/painting/FocusRingPainter.java
  - src/main/java/com/dwc/laf/painting/ShadowPainter.java
  - src/test/java/com/dwc/laf/painting/FocusRingPainterTest.java
  - src/test/java/com/dwc/laf/painting/ShadowPainterTest.java
autonomous: true

must_haves:
  truths:
    - "Focus ring paints as a semi-transparent outline outside component bounds matching DWC box-shadow 0 0 0 3px hsla(H,S,45%,0.4)"
    - "Focus ring follows component arc radius with outer arc expanded by ring width"
    - "Box shadow renders behind component using cached blurred BufferedImage with SoftReference"
    - "Shadow cache is keyed by all visual parameters (size, arc, blur, color) and invalidates on change"
    - "Gaussian blur uses two-pass separable ConvolveOp with EDGE_ZERO_FILL for soft shadow edges"
  artifacts:
    - path: "src/main/java/com/dwc/laf/painting/FocusRingPainter.java"
      provides: "Focus ring painting outside component bounds with DWC-style semi-transparent outline"
      exports: ["paintFocusRing"]
    - path: "src/main/java/com/dwc/laf/painting/ShadowPainter.java"
      provides: "Box shadow rendering with Gaussian blur and SoftReference image caching"
      exports: ["paintShadow"]
    - path: "src/test/java/com/dwc/laf/painting/FocusRingPainterTest.java"
      provides: "Tests for focus ring geometry, color, and painting"
    - path: "src/test/java/com/dwc/laf/painting/ShadowPainterTest.java"
      provides: "Tests for shadow rendering, blur, caching, and cache invalidation"
  key_links:
    - from: "src/main/java/com/dwc/laf/painting/FocusRingPainter.java"
      to: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      via: "Uses createRoundedShape and setupPaintingHints for ring geometry"
      pattern: "PaintUtils\\.createRoundedShape|PaintUtils\\.setupPaintingHints"
    - from: "src/main/java/com/dwc/laf/painting/ShadowPainter.java"
      to: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      via: "Uses createRoundedShape for shadow shape"
      pattern: "PaintUtils\\.createRoundedShape"
    - from: "src/main/java/com/dwc/laf/painting/ShadowPainter.java"
      to: "src/main/java/com/dwc/laf/painting/HiDpiUtils.java"
      via: "Uses getScaleFactor for device-resolution shadow images"
      pattern: "HiDpiUtils\\.getScaleFactor"
    - from: "src/main/java/com/dwc/laf/painting/ShadowPainter.java"
      to: "java.awt.image.ConvolveOp"
      via: "Two-pass separable Gaussian blur"
      pattern: "ConvolveOp"
---

<objective>
Build FocusRingPainter and ShadowPainter -- the two visual effect utilities that depend on PaintUtils and HiDpiUtils from Plan 01.

Purpose: Focus rings and box shadows are the two most prominent visual effects in DWC components. Every delegate from Phases 4-7 needs these for focus-visible styling and elevation/depth.
Output: 2 production classes + 2 test classes in `com.dwc.laf.painting` package.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-shared-painting-utilities/03-RESEARCH.md
@.planning/phases/03-shared-painting-utilities/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FocusRingPainter - DWC-style focus ring outside component bounds</name>
  <files>
    src/main/java/com/dwc/laf/painting/FocusRingPainter.java
    src/test/java/com/dwc/laf/painting/FocusRingPainterTest.java
  </files>
  <action>
Create `com.dwc.laf.painting.FocusRingPainter` as a final class with private constructor.

Implement these static methods:

1. `paintFocusRing(Graphics2D g, float x, float y, float width, float height, float componentArc, float ringWidth, Color ringColor)` -> void
   - If ringColor is null or ringWidth <= 0, return immediately
   - Save hints via PaintUtils.setupPaintingHints(g)
   - Set g.setColor(ringColor) -- the ringColor should already include alpha (semi-transparent per DWC: 0.4 alpha)
   - Calculate outer ring bounds: rx = x - ringWidth, ry = y - ringWidth, rw = width + ringWidth * 2, rh = height + ringWidth * 2
   - Calculate outerArc = componentArc + ringWidth (the ring follows and expands the component's arc)
   - Build Path2D.Float with WIND_EVEN_ODD: append outer shape via PaintUtils.createRoundedShape(rx, ry, rw, rh, outerArc), append inner shape via PaintUtils.createRoundedShape(x, y, width, height, componentArc)
   - g.fill(path) -- even-odd fill creates the ring outline
   - Restore hints via PaintUtils.restorePaintingHints(g, saved)

DWC reference: focus ring = box-shadow: 0 0 0 3px hsla(H, S, 45%, 0.4). The 3px is ringWidth, the hsla color with 0.4 alpha is ringColor. Delegates will construct the color from CSS tokens.

Tests (FocusRingPainterTest.java):
- testPaintFocusRing_nullColor: verify no exception, no pixels painted
- testPaintFocusRing_zeroWidth: verify no exception, no pixels painted
- testPaintFocusRing_paintsPixels: paint on 100x40 BufferedImage with ring width 3, color with alpha 102 (0.4*255). Verify pixels exist in the ring area (outside component bounds but inside outer ring bounds). Check a pixel at (x - ringWidth/2, height/2) region is non-transparent.
- testPaintFocusRing_ringColorPreserved: paint with specific RGBA color, verify painted pixels match expected color components (accounting for alpha compositing on transparent background)
- testPaintFocusRing_restoresHints: verify Graphics2D hints are the same before and after call
- testPaintFocusRing_expandsArc: verify that the outer ring uses a larger arc than the component arc (test indirectly by painting a 0-arc component and verifying the ring area covers corner pixels that a non-expanded arc would miss)

Use BufferedImage(TYPE_INT_ARGB) sized to accommodate the ring (e.g., 120x60 for a component at offset 10,10 size 100x40 with 3px ring).
  </action>
  <verify>cd /Users/beff/_lab/dwclaf && mvn test -pl . -Dtest="com.dwc.laf.painting.FocusRingPainterTest" -q</verify>
  <done>FocusRingPainter.paintFocusRing paints semi-transparent outline outside component bounds using even-odd fill. Outer arc expands by ringWidth. Hints saved/restored. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: ShadowPainter - box shadow with Gaussian blur and SoftReference caching</name>
  <files>
    src/main/java/com/dwc/laf/painting/ShadowPainter.java
    src/test/java/com/dwc/laf/painting/ShadowPainterTest.java
  </files>
  <action>
Create `com.dwc.laf.painting.ShadowPainter` as a final class with private constructor.

Internal types:

1. `record ShadowCacheKey(int width, int height, float arc, float blurRadius, int shadowColorRgb)` -- package-private record inside ShadowPainter. All visual parameters that affect the shadow image. Uses record's auto-generated hashCode/equals.

2. `private static final ConcurrentHashMap<ShadowCacheKey, SoftReference<BufferedImage>> cache = new ConcurrentHashMap<>()` -- thread-safe shadow image cache with memory-sensitive entries.

Implement these static methods:

3. `paintShadow(Graphics2D g, float x, float y, float width, float height, float arc, float blurRadius, float offsetX, float offsetY, Color shadowColor)` -> void
   - If shadowColor is null or blurRadius <= 0, return
   - Clamp blurRadius to max 50f (practical desktop limit per research -- DWC uses up to 100px which is excessive for Swing components)
   - Calculate padding = (int) Math.ceil(blurRadius * 3) -- blur kernel extends 3 sigma
   - imageWidth = (int) width + padding * 2, imageHeight = (int) height + padding * 2
   - Build cache key from imageWidth, imageHeight, arc, blurRadius, shadowColor.getRGB()
   - Check cache: get SoftReference, dereference, use if non-null
   - On cache miss: create new BufferedImage(imageWidth, imageHeight, TYPE_INT_ARGB)
     - Get its Graphics2D, set color to shadowColor
     - Fill createRoundedShape(padding, padding, width, height, arc) centered in the padded image
     - Dispose the image's Graphics2D
     - Apply Gaussian blur via applyGaussianBlur(image, blurRadius)
     - Store in cache with SoftReference
   - Draw the cached/created image: g.drawImage(image, (int)(x + offsetX - padding), (int)(y + offsetY - padding), imageWidth, imageHeight, null)
   Note: Draw at logical dimensions (imageWidth x imageHeight), not device dimensions. The Graphics2D transform handles HiDPI scaling. For prototype, skip device-resolution shadow images (optimize later if needed).

4. `applyGaussianBlur(BufferedImage src, float radius)` -> `BufferedImage` -- private static
   - Calculate kernel size: (int) Math.ceil(radius * 3) * 2 + 1 (covers 3 sigma)
   - Create 1D Gaussian kernel data: float[] of kernel size, compute exp(-(dist^2)/(2*sigma^2)) where sigma = radius, normalize to sum = 1.0
   - Horizontal pass: new Kernel(kernelSize, 1, kernelData), new ConvolveOp(kernel, EDGE_ZERO_FILL, null), filter src to temp image
   - Vertical pass: new Kernel(1, kernelSize, kernelData), new ConvolveOp(kernel, EDGE_ZERO_FILL, null), filter temp to result
   - Return result

5. `clearCache()` -> void -- package-private, for testing. Calls cache.clear().

Tests (ShadowPainterTest.java):
- testPaintShadow_nullColor: verify no exception
- testPaintShadow_zeroBlur: verify no exception, no shadow painted
- testPaintShadow_paintsSoftPixels: paint shadow on 200x100 BufferedImage for a 100x40 component at (50, 30) with blurRadius 5, verify pixels exist beyond component bounds (the shadow spread area). Check that a pixel at (50 + offsetX - 2, 30 + offsetY + 42) has non-zero alpha.
- testPaintShadow_caching: call paintShadow twice with identical parameters on same-sized component, verify second call is faster (or verify cache has entry by calling clearCache and checking behavior changes). Simpler: call paintShadow, then clearCache(), then call again -- both should produce same visual result.
- testPaintShadow_cacheMissOnDifferentSize: paint with width=100, then width=120, verify both produce results (cache key differs)
- testPaintShadow_blurRadiusClamped: paint with blurRadius=200, verify no exception and image is reasonably sized (not OOM)
- testGaussianBlur_producesBlurredImage: create a BufferedImage with a single opaque pixel in center, apply blur, verify surrounding pixels now have non-zero alpha (blur spread the color)
- testGaussianBlur_zeroRadius: verify returns original image unchanged

Note: Make applyGaussianBlur package-private (not private) for direct testing. Or test indirectly through paintShadow. Prefer package-private for testability -- this is consistent with the project's pattern of package-private helpers.
  </action>
  <verify>cd /Users/beff/_lab/dwclaf && mvn test -pl . -Dtest="com.dwc.laf.painting.ShadowPainterTest" -q</verify>
  <done>ShadowPainter.paintShadow renders blurred shadow behind component bounds with SoftReference cache. Two-pass separable ConvolveOp with EDGE_ZERO_FILL produces soft edges. Blur radius clamped to 50px. All tests pass.</done>
</task>

</tasks>

<verification>
Run the full test suite to ensure no regressions:
```
cd /Users/beff/_lab/dwclaf && mvn test -q
```
All existing tests plus all new painting utility tests must pass.

Verify the complete painting package:
```
ls src/main/java/com/dwc/laf/painting/
```
Should list: FocusRingPainter.java, HiDpiUtils.java, PaintUtils.java, ShadowPainter.java, StateColorResolver.java

Verify all test classes:
```
ls src/test/java/com/dwc/laf/painting/
```
Should list: FocusRingPainterTest.java, HiDpiUtilsTest.java, PaintUtilsTest.java, ShadowPainterTest.java, StateColorResolverTest.java
</verification>

<success_criteria>
- FocusRingPainter paints semi-transparent ring outside component bounds using even-odd fill
- FocusRingPainter outer arc = componentArc + ringWidth for smooth ring curvature
- ShadowPainter renders blurred shadow image behind component with correct offset
- ShadowPainter caches shadow images via ConcurrentHashMap + SoftReference
- ShadowPainter cache key includes all visual parameters (width, height, arc, blur, color)
- Gaussian blur uses two-pass separable ConvolveOp with EDGE_ZERO_FILL
- Shadow blur radius clamped to 50px max for practical desktop use
- Shadow image padded by 3*blurRadius on each side to avoid edge clipping
- All new tests pass, full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-shared-painting-utilities/03-02-SUMMARY.md`
</output>
