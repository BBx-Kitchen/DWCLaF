---
phase: 04-button-component
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/main/java/com/dwc/laf/ui/DwcButtonUI.java
  - src/main/java/com/dwc/laf/DwcLookAndFeel.java
  - src/test/java/com/dwc/laf/ui/DwcButtonUITest.java
autonomous: true

must_haves:
  truths:
    - "JButton paints with rounded background, border, and text from CSS tokens"
    - "JButton shows visually distinct states: normal, hover, pressed, focused, disabled"
    - "JButton supports primary variant via putClientProperty('dwc.buttonType', 'primary') with accent-colored background"
    - "JButton renders icons alongside text with correct gap and layout"
    - "JButton respects contentAreaFilled and borderPainted flags"
    - "JButton has minimum width of 72px and minimum height of 36px"
    - "JButton focus ring paints when focused using FocusRingPainter"
    - "Disabled JButton paints at reduced opacity (Component.disabledOpacity)"
  artifacts:
    - path: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      provides: "Complete ButtonUI delegate with paint pipeline, variant support, state handling"
      min_lines: 150
    - path: "src/test/java/com/dwc/laf/ui/DwcButtonUITest.java"
      provides: "Tests for UI installation, preferred size, variant detection, state color resolution"
      min_lines: 60
  key_links:
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "StateColorResolver.resolve"
      via: "resolves background/foreground color based on button state"
      pattern: "StateColorResolver\\.resolve"
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "PaintUtils.paintRoundedBackground"
      via: "paints rounded button background"
      pattern: "PaintUtils\\.paintRoundedBackground"
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "FocusRingPainter.paintFocusRing"
      via: "paints focus ring when button has focus"
      pattern: "FocusRingPainter\\.paintFocusRing"
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "StateColorResolver.paintWithOpacity"
      via: "paints disabled button at reduced opacity"
      pattern: "StateColorResolver\\.paintWithOpacity"
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "SwingUtilities.layoutCompoundLabel"
      via: "positions icon and text within button bounds"
      pattern: "SwingUtilities\\.layoutCompoundLabel"
    - from: "src/main/java/com/dwc/laf/ui/DwcButtonUI.java"
      to: "DwcButtonBorder"
      via: "installed as button border in installDefaults()"
      pattern: "DwcButtonBorder"
    - from: "src/main/java/com/dwc/laf/DwcLookAndFeel.java"
      to: "DwcButtonUI"
      via: "registered in initClassDefaults()"
      pattern: "ButtonUI.*DwcButtonUI"
---

<objective>
Create DwcButtonUI delegate extending BasicButtonUI with complete paint pipeline (background, border, icon, text, focus ring), primary/default variant support, five visual states, and register it in DwcLookAndFeel.

Purpose: This is the first complete component delegate, proving the entire CSS-to-delegate pipeline works end-to-end: CSS tokens parsed, mapped to UIDefaults, read by delegate, painted onto Swing component.

Output: DwcButtonUI class with full rendering, L&F registration, tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-button-component/04-RESEARCH.md
@.planning/phases/04-button-component/04-01-SUMMARY.md
@src/main/java/com/dwc/laf/DwcLookAndFeel.java
@src/main/java/com/dwc/laf/ui/DwcButtonBorder.java
@src/main/java/com/dwc/laf/painting/PaintUtils.java
@src/main/java/com/dwc/laf/painting/StateColorResolver.java
@src/main/java/com/dwc/laf/painting/FocusRingPainter.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: DwcButtonUI delegate with complete paint pipeline</name>
  <files>
    src/main/java/com/dwc/laf/ui/DwcButtonUI.java
  </files>
  <action>
Create `DwcButtonUI` extending `BasicButtonUI` in `com.dwc.laf.ui` package.

**Instance fields** (loaded from UIDefaults in installDefaults):
- Colors: `background`, `foreground`, `hoverBackground`, `pressedBackground`, `disabledText`
- Primary variant colors: `defaultBackground`, `defaultForeground`, `defaultHoverBackground`, `defaultPressedBackground`
- Focus ring color: `focusRingColor`
- Border color: `borderColor`
- Dimensions: `arc` (int), `focusWidth` (int), `borderWidth` (int), `minimumWidth` (int)
- Opacity: `disabledOpacity` (float)

**createUI(JComponent c):** Return `new DwcButtonUI()` -- per-component instances, NOT shared singleton. Must be `public static` with exact signature `ComponentUI createUI(JComponent c)`.

**installDefaults(AbstractButton b):**
- Call `super.installDefaults(b)` first
- Read all colors from UIManager: `Button.background`, `Button.foreground`, `Button.hoverBackground`, `Button.pressedBackground`, `Button.disabledText`, `Button.default.background`, `Button.default.foreground`, `Button.default.hoverBackground`, `Button.default.pressedBackground`, `Component.focusRingColor`, `Button.borderColor`
- Read dimensions: `Button.arc`, `Component.focusWidth`, `Component.borderWidth`, `Button.minimumWidth` (default 72)
- Read `Component.disabledOpacity` as float (default 0.6f) -- use `UIManager.get("Component.disabledOpacity")` and cast since `UIManager.getFloat()` does not exist; if value is `Number`, call `.floatValue()`
- Call `b.setRolloverEnabled(true)` to enable hover state tracking
- Set `b.setOpaque(false)` ONLY if the current opaque value is from the L&F (check: `LookAndFeel.installProperty(b, "opaque", false)` which respects UIResource contract)
- Install `DwcButtonBorder` as the button border: `LookAndFeel.installBorder(b, "Button.border")` -- but this requires "Button.border" to be set in UIDefaults. Instead, directly: `if (b.getBorder() == null || b.getBorder() instanceof javax.swing.plaf.UIResource) { b.setBorder(new DwcButtonBorder()); }`

**uninstallDefaults(AbstractButton b):**
- Call `super.uninstallDefaults(b)` -- this handles removing UIResource values

**paint(Graphics g, JComponent c):**
This is the core rendering method. Do NOT call `super.paint()` (it would call paintButtonPressed which fights custom painting). Full control here.

```
AbstractButton b = (AbstractButton) c;
Graphics2D g2 = (Graphics2D) g.create();
try {
    int width = c.getWidth();
    int height = c.getHeight();
    boolean primary = isPrimary(b);

    int fw = focusWidth;
    int bw = borderWidth;

    // Content area (inside focus ring reservation)
    float cx = fw;
    float cy = fw;
    float cw = width - fw * 2;
    float ch = height - fw * 2;

    // 1. Paint background
    if (b.isContentAreaFilled()) {
        Color bg = resolveBackground(b, primary);
        if (!b.isEnabled()) {
            StateColorResolver.paintWithOpacity(g2, disabledOpacity, () -> {
                PaintUtils.paintRoundedBackground(g2, cx, cy, cw, ch, arc, bg);
            });
        } else {
            PaintUtils.paintRoundedBackground(g2, cx, cy, cw, ch, arc, bg);
        }
    }

    // 2. Border painted by DwcButtonBorder (not here)

    // 3. Layout icon + text
    g2.setFont(b.getFont());
    FontMetrics fm = g2.getFontMetrics();
    Rectangle viewRect = new Rectangle();
    Rectangle iconRect = new Rectangle();
    Rectangle textRect = new Rectangle();
    Insets insets = b.getInsets();
    viewRect.x = insets.left;
    viewRect.y = insets.top;
    viewRect.width = width - (insets.left + insets.right);
    viewRect.height = height - (insets.top + insets.bottom);

    String text = SwingUtilities.layoutCompoundLabel(
        c, fm, b.getText(), b.getIcon(),
        b.getVerticalAlignment(), b.getHorizontalAlignment(),
        b.getVerticalTextPosition(), b.getHorizontalTextPosition(),
        viewRect, iconRect, textRect,
        b.getText() == null ? 0 : b.getIconTextGap()
    );

    // 4. Paint icon
    if (b.getIcon() != null) {
        Icon icon = getStateIcon(b);
        if (icon != null) {
            if (!b.isEnabled()) {
                StateColorResolver.paintWithOpacity(g2, disabledOpacity, () -> {
                    icon.paintIcon(c, g2, iconRect.x, iconRect.y);
                });
            } else {
                icon.paintIcon(c, g2, iconRect.x, iconRect.y);
            }
        }
    }

    // 5. Paint text
    if (text != null && !text.isEmpty()) {
        Color fg = resolveForeground(b, primary);
        if (!b.isEnabled()) {
            fg = disabledText != null ? disabledText : foreground;
            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, disabledOpacity));
        }
        g2.setColor(fg);
        BasicGraphicsUtils.drawStringUnderlineCharAt(g2, text,
            b.getDisplayedMnemonicIndex(),
            textRect.x, textRect.y + fm.getAscent());
    }

    // 6. Paint focus ring
    if (b.isFocusPainted() && b.hasFocus()) {
        Color ringColor = focusRingColor;
        if (ringColor != null) {
            FocusRingPainter.paintFocusRing(g2, cx, cy, cw, ch, arc, fw, ringColor);
        }
    }
} finally {
    g2.dispose();
}
```

**resolveBackground(AbstractButton b, boolean primary):** Private helper.
- If primary: return `StateColorResolver.resolve(b, defaultBackground, null, null, defaultHoverBackground, defaultPressedBackground)`
- Else: return `StateColorResolver.resolve(b, background, null, null, hoverBackground, pressedBackground)`

**resolveForeground(AbstractButton b, boolean primary):** Private helper.
- If primary: return `defaultForeground != null ? defaultForeground : foreground`
- Else: return `foreground`

**isPrimary(AbstractButton b):** `return "primary".equals(b.getClientProperty("dwc.buttonType"));`

**getStateIcon(AbstractButton b):** Private helper. Select correct icon by state:
- If `!model.isEnabled()`: return `b.getDisabledIcon()` if non-null, else `b.getIcon()`
- If `model.isArmed() && model.isPressed()`: return `b.getPressedIcon()` if non-null, else `b.getIcon()`
- If `model.isRollover()`: return `b.getRolloverIcon()` if non-null, else `b.getIcon()`
- Default: return `b.getIcon()`

**getPreferredSize(JComponent c):** Override to enforce minimum dimensions.
- Call `Dimension d = super.getPreferredSize(c)` (BasicButtonUI computes from icon+text+insets)
- Enforce `d.width = Math.max(d.width, minimumWidth)` only if button has text (not icon-only)
- Enforce `d.height = Math.max(d.height, 36)` (DWC --dwc-size-m = 2.25rem = 36px)
- Return d

**getMinimumSize(JComponent c):** Return `getPreferredSize(c)` -- buttons should not shrink below preferred.

**Imports needed:** `javax.swing.*`, `javax.swing.plaf.*`, `javax.swing.plaf.basic.*`, `java.awt.*`, `java.awt.geom.*`, `com.dwc.laf.painting.*`, `com.dwc.laf.ui.DwcButtonBorder`
  </action>
  <verify>`mvn compile -pl .` succeeds with no compilation errors</verify>
  <done>DwcButtonUI compiles and contains createUI, installDefaults, paint (with full 6-step pipeline), resolveBackground, resolveForeground, isPrimary, getStateIcon, getPreferredSize, getMinimumSize</done>
</task>

<task type="auto">
  <name>Task 2: L&F registration and DwcButtonUI tests</name>
  <files>
    src/main/java/com/dwc/laf/DwcLookAndFeel.java
    src/test/java/com/dwc/laf/ui/DwcButtonUITest.java
  </files>
  <action>
**DwcLookAndFeel.initClassDefaults update:**
In the existing `initClassDefaults(UIDefaults table)` method, after `super.initClassDefaults(table)`, add:
```java
table.put("ButtonUI", "com.dwc.laf.ui.DwcButtonUI");
```
This registers DwcButtonUI as the ComponentUI for all JButton instances. Also add the border to component defaults -- in `initComponentDefaults`, inside the `initButtonDefaults` method (from Plan 01), add:
```java
table.put("Button.border", new javax.swing.plaf.BorderUIResource(new DwcButtonBorder()));
```
This allows `LookAndFeel.installBorder(b, "Button.border")` to work if used, and is the standard L&F pattern.

**DwcButtonUITest:**
Write tests using `@BeforeEach` to install DwcLookAndFeel via `UIManager.setLookAndFeel(new DwcLookAndFeel())` and `@AfterEach` to restore previous L&F.

Tests:
1. **testUIInstalled:** Create `new JButton("Test")`, verify `button.getUI() instanceof DwcButtonUI`
2. **testPerComponentInstance:** Create two JButtons, verify `button1.getUI() != button2.getUI()` (not shared singleton)
3. **testRolloverEnabled:** Create JButton, verify `button.isRolloverEnabled() == true` after UI installation
4. **testNotOpaque:** Create JButton, verify `button.isOpaque() == false`
5. **testBorderInstalled:** Create JButton, verify `button.getBorder() instanceof DwcButtonBorder`
6. **testPreferredSizeMinimumWidth:** Create `new JButton("OK")` (short text), verify `button.getPreferredSize().width >= 72`
7. **testPreferredSizeMinimumHeight:** Create `new JButton("OK")`, verify `button.getPreferredSize().height >= 36`
8. **testPrimaryVariant:** Create JButton, `button.putClientProperty("dwc.buttonType", "primary")`, verify `button.getUI()` recognizes primary via calling paint without error (smoke test: paint to BufferedImage)
9. **testPaintNoError:** Create JButton("Test"), create BufferedImage(200,40), get Graphics2D, call `button.setSize(200, 40)`, `button.paint(g2)` -- verify no exceptions thrown (smoke test for full paint pipeline)
10. **testDisabledPaintNoError:** Same as above but `button.setEnabled(false)` first

For paint smoke tests: create `BufferedImage(200, 40, TYPE_INT_ARGB)`, get `createGraphics()`, set button size, call `button.paint(g)`. Verify no exception is thrown. These are integration tests proving the full pipeline works.

**Important:** All tests must run headless-safe. JButton can be constructed without a visible frame. The `paint()` call works with any Graphics2D (including from BufferedImage).
  </action>
  <verify>`mvn test -Dsurefire.useFile=false` -- all tests pass including new DwcButtonUITest</verify>
  <done>DwcButtonUI registered in DwcLookAndFeel.initClassDefaults; 10 tests verify UI installation, per-component instances, rollover/opacity/border setup, preferred size minimums, primary variant, and smoke-test paint pipeline for enabled and disabled states</done>
</task>

</tasks>

<verification>
1. `mvn test -Dsurefire.useFile=false` -- all tests pass (zero failures)
2. After `UIManager.setLookAndFeel(new DwcLookAndFeel())`, a `new JButton("Test")` has:
   - `getUI() instanceof DwcButtonUI`
   - `getBorder() instanceof DwcButtonBorder`
   - `isRolloverEnabled() == true`
   - `isOpaque() == false`
   - `getPreferredSize().width >= 72`
   - `getPreferredSize().height >= 36`
3. Painting a JButton to a BufferedImage produces no exceptions for: default variant, primary variant, enabled, disabled
4. BTN-01 satisfied: rounded background + border + text from CSS tokens
5. BTN-02 satisfied: StateColorResolver handles normal/hover/pressed/focused/disabled
6. BTN-03 satisfied: primary variant via client property reads accent colors
7. BTN-04 satisfied: SwingUtilities.layoutCompoundLabel handles icon+text
</verification>

<success_criteria>
- DwcButtonUI is the active ButtonUI for JButton when DwcLookAndFeel is installed
- Each JButton gets its own DwcButtonUI instance (not shared)
- Paint pipeline renders background, border, icon, text, focus ring in correct order
- Primary variant uses accent colors; default variant uses neutral colors
- Disabled state paints at reduced opacity
- Focus ring paints when button has focus
- Minimum size enforced (72px wide, 36px tall)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-button-component/04-02-SUMMARY.md`
</output>
