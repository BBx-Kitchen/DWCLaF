---
phase: 05-text-input-components
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java
  - src/test/java/com/dwc/laf/ui/DwcTextFieldUITest.java
autonomous: true

must_haves:
  truths:
    - "JTextField paints with rounded background from CSS tokens instead of rectangular fill"
    - "JTextField shows visually distinct hover state (border color changes on mouse enter/exit)"
    - "JTextField shows visually distinct focused state (focus ring painted, border color changes)"
    - "JTextField renders placeholder text in muted color when document is empty"
    - "JTextField disabled state renders at reduced opacity"
    - "Each JTextField gets its own DwcTextFieldUI instance (no shared state across fields)"
  artifacts:
    - path: "src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java"
      provides: "Complete TextFieldUI delegate with paintSafely override, hover/focus listeners, placeholder painting"
      min_lines: 150
    - path: "src/test/java/com/dwc/laf/ui/DwcTextFieldUITest.java"
      provides: "Tests for UI installation, per-component instances, placeholder, hover state, paint smoke test"
      min_lines: 60
  key_links:
    - from: "src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java"
      to: "PaintUtils"
      via: "paintRoundedBackground and setupPaintingHints for background rendering"
      pattern: "PaintUtils\\.paintRoundedBackground"
    - from: "src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java"
      to: "FocusRingPainter"
      via: "paintFocusRing for focus ring rendering"
      pattern: "FocusRingPainter\\.paintFocusRing"
    - from: "src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java"
      to: "BasicTextFieldUI"
      via: "super.paintSafely(g) for text/caret/selection rendering with ORIGINAL Graphics"
      pattern: "super\\.paintSafely"
---

<objective>
DwcTextFieldUI delegate extending BasicTextFieldUI with complete paintSafely pipeline: rounded background, hover/focus state tracking, placeholder text rendering, and focus ring painting.

Purpose: This is the core rendering delegate that makes JTextField look like a DWC web input. It applies the CSS design tokens (loaded by Plan 05-01) to produce a visually faithful rendering with all interactive states.

Output: DwcTextFieldUI.java with full paint pipeline and state management, DwcTextFieldUITest.java with comprehensive tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-button-component/04-02-SUMMARY.md
@.planning/phases/05-text-input-components/05-RESEARCH.md
@.planning/phases/05-text-input-components/05-01-SUMMARY.md
@src/main/java/com/dwc/laf/ui/DwcButtonUI.java
@src/main/java/com/dwc/laf/painting/PaintUtils.java
@src/main/java/com/dwc/laf/painting/FocusRingPainter.java
@src/main/java/com/dwc/laf/painting/StateColorResolver.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: DwcTextFieldUI delegate with paintSafely pipeline, hover/focus listeners, and placeholder text</name>
  <files>
    src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java
  </files>
  <action>
Create DwcTextFieldUI extending BasicTextFieldUI in com.dwc.laf.ui package.

**Fields (cached from UIDefaults in installDefaults):**
- Colors: background, foreground, hoverBackground, hoverBorderColor, placeholderForeground, focusRingColor
- Dimensions: arc (int), focusWidth (int), borderWidth (int), disabledOpacity (float)
- State: hover (boolean), hoverListener (MouseListener), focusRepaintListener (FocusListener)

**createUI(JComponent c):**
Return `new DwcTextFieldUI()` -- per-component instances, NOT a shared singleton (same as DwcButtonUI pattern, prevents hover state leaking between text fields).

**installDefaults():**
1. Call super.installDefaults()
2. LookAndFeel.installProperty(getComponent(), "opaque", false) -- required for rounded corners; prevents rectangular background artifact. Use installProperty (not setOpaque) so application-set values are preserved (UIResource contract).
3. Read all colors and dimensions from UIManager into cached fields:
   - background = UIManager.getColor("TextField.background")
   - foreground = UIManager.getColor("TextField.foreground")
   - hoverBackground = UIManager.getColor("TextField.hoverBackground")
   - hoverBorderColor = UIManager.getColor("TextField.hoverBorderColor")
   - placeholderForeground = UIManager.getColor("TextField.placeholderForeground")
   - focusRingColor = UIManager.getColor("Component.focusRingColor")
   - arc = UIManager.getInt("TextField.arc")
   - focusWidth = UIManager.getInt("Component.focusWidth")
   - borderWidth = UIManager.getInt("Component.borderWidth")
   - disabledOpacity = UIManager.getFloat("Component.disabledOpacity") -- if 0, default to 0.4f

Note: UIManager.getFloat returns 0 if key missing. Check for 0 and use 0.4f default.

**installListeners():**
1. Call super.installListeners()
2. Install MouseAdapter as hoverListener on getComponent():
   - mouseEntered: set hover=true, set client property "DwcTextFieldUI.hover" to Boolean.TRUE on component, call getComponent().repaint()
   - mouseExited: set hover=false, set client property "DwcTextFieldUI.hover" to Boolean.FALSE on component, call getComponent().repaint()
   Note: The client property is read by DwcTextFieldBorder.paintBorder() for border color resolution.
3. Install FocusListener as focusRepaintListener on getComponent():
   - focusGained: getComponent().repaint() (triggers border color update + focus ring paint)
   - focusLost: getComponent().repaint() (removes focus ring + reverts border color)

**uninstallListeners():**
1. Call super.uninstallListeners()
2. Remove hoverListener from getComponent(), set hoverListener = null
3. Remove focusRepaintListener from getComponent(), set focusRepaintListener = null

**paintBackground(Graphics g):**
Override as a NO-OP (empty method body). Since opaque=false, BasicTextUI.paintSafely() will NOT call this. But override it defensively -- if something else calls it, we don't want a rectangular fill.

**paintSafely(Graphics g):**
This is the core paint pipeline. BasicTextUI.paint() is final; all custom painting goes through paintSafely().

```
1. Get component: JTextComponent c = getComponent()

2. Paint rounded background (BEFORE super, since opaque=false means super skips paintBackground):
   {
     Graphics2D g2 = (Graphics2D) g.create();
     try {
       Object[] saved = PaintUtils.setupPaintingHints(g2);
       Color bg = resolveBackground(c);
       // Paint at (focusWidth, focusWidth) inset, with arc
       PaintUtils.paintRoundedBackground(g2, focusWidth, focusWidth,
           c.getWidth() - focusWidth * 2, c.getHeight() - focusWidth * 2, arc, bg);
       PaintUtils.restorePaintingHints(g2, saved);
     } finally {
       g2.dispose();
     }
   }

3. Call super.paintSafely(g) with the ORIGINAL Graphics object.
   CRITICAL: Do NOT pass a g.create() clone to super. BasicTextUI.paintSafely() sets up
   clip regions and accesses the component -- it needs the original graphics context.
   This paints text content, highlights, and caret.

4. Paint placeholder text (AFTER super, so it layers correctly when document is empty):
   {
     Graphics2D g2 = (Graphics2D) g.create();
     try {
       paintPlaceholder(g2, c);
     } finally {
       g2.dispose();
     }
   }

5. Paint focus ring (AFTER everything, on top):
   if (c.hasFocus()) {
     Graphics2D g2 = (Graphics2D) g.create();
     try {
       FocusRingPainter.paintFocusRing(g2, focusWidth, arc,
           c.getWidth(), c.getHeight(), focusRingColor);
     } finally {
       g2.dispose();
     }
   }

6. Handle disabled state: If !c.isEnabled(), wrap the ENTIRE paintSafely in an
   AlphaComposite.SrcOver with disabledOpacity. Do this by checking at the TOP of
   paintSafely and setting the composite on the original graphics (save/restore).
   Actually, better approach: wrap the entire method. At the start of paintSafely:

   Composite oldComposite = null;
   if (!c.isEnabled() && g instanceof Graphics2D g2d) {
       oldComposite = g2d.getComposite();
       g2d.setComposite(AlphaComposite.SrcOver.derive(disabledOpacity));
   }
   // ... all painting steps 2-5 ...
   if (oldComposite != null && g instanceof Graphics2D g2d) {
       g2d.setComposite(oldComposite);
   }
```

**resolveBackground(JTextComponent c):**
Private helper returning the correct background color based on state:
- If hover AND not focused -> return hoverBackground (or fall back to background if null)
- Otherwise -> return background
Note: DWC web inputs use the SAME background for normal and hover states in the default light theme (both are --dwc-color-default-light). But we handle it correctly in case themes differ.

**paintPlaceholder(Graphics2D g2, JTextComponent c):**
Private method to paint placeholder text:
1. If c.getDocument().getLength() > 0, return (has text, no placeholder)
2. Read placeholder string from client property: (String) c.getClientProperty("JTextField.placeholderText")
3. If placeholder is null or empty, return
4. Set color to placeholderForeground (fall back to Color.GRAY if null)
5. Set font to c.getFont()
6. Get FontMetrics, get component Insets
7. Calculate x = insets.left, y = insets.top + fm.getAscent()
8. Enable text antialiasing: g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB) -- or use the desktop hints if available
9. Clip placeholder to available width: calculate availWidth = c.getWidth() - insets.left - insets.right. If the placeholder string is wider than availWidth, use SwingUtilities.clipStringIfNecessary (or just let it clip via the existing graphics clip)
10. Draw the string: g2.drawString(placeholder, x, y)

**getPreferredSize(JComponent c):**
Override to enforce minimum height of 36px (matching DWC input height):
```java
Dimension size = super.getPreferredSize(c);
if (size != null) {
    size.height = Math.max(size.height, 36);
}
return size;
```
  </action>
  <verify>Run `mvn compile -f /Users/beff/_lab/dwclaf/pom.xml` -- compilation succeeds with no errors.</verify>
  <done>DwcTextFieldUI.java exists with createUI returning per-component instances, installDefaults setting opaque=false and caching UIDefaults, installListeners with hover MouseListener and focus FocusListener, paintSafely with 5-step pipeline (disabled opacity, background, super text, placeholder, focus ring), and paintBackground as no-op.</done>
</task>

<task type="auto">
  <name>Task 2: DwcTextFieldUI tests</name>
  <files>
    src/test/java/com/dwc/laf/ui/DwcTextFieldUITest.java
  </files>
  <action>
Create comprehensive tests for DwcTextFieldUI in DwcTextFieldUITest.java.

Use @BeforeEach to install DwcLookAndFeel via UIManager.setLookAndFeel(new DwcLookAndFeel()), and @AfterEach to restore the original L&F.

**Tests:**

1. **testCreateUIReturnsPerComponentInstances:** Create two JTextFields. Call DwcTextFieldUI.createUI on each. Assert the returned instances are not the same object (!=).

2. **testInstallSetsOpaqueToFalse:** Create a JTextField. Assert that tf.isOpaque() == false after L&F installation.

3. **testInstallSetsBorder:** Create a JTextField. Assert tf.getBorder() is not null. Assert the border insets include focus width padding (insets.left > 6, confirming focusWidth + borderWidth + margin).

4. **testPreferredSizeMinimumHeight:** Create a JTextField with short text. Get preferred size. Assert height >= 36.

5. **testHoverStateViaClientProperty:** Create a JTextField. Simulate hover by setting client property "DwcTextFieldUI.hover" to Boolean.TRUE. Assert the property is set (this is how DwcTextFieldBorder reads hover state).

6. **testPlaceholderClientProperty:** Create a JTextField. Set client property "JTextField.placeholderText" to "Enter name...". Assert the client property is readable and matches the set value.

7. **testPaintSmokeTest:** Create a JTextField with text "Hello". Create a BufferedImage (200x40, TYPE_INT_ARGB). Get Graphics2D from image. Call tf.setSize(200, 40) and tf.doLayout(). Call tf.paint(g2). Assert no exceptions thrown. Check that the image is not entirely transparent (at least one non-zero pixel, confirming something was painted).

8. **testPaintWithPlaceholderSmokeTest:** Create an empty JTextField with placeholder client property set. Create a BufferedImage, paint, verify no exceptions and something was rendered.

9. **testDisabledStateDoesNotThrow:** Create a JTextField, set enabled=false. Paint to BufferedImage. Assert no exceptions.

10. **testUIClassRegistered:** Assert UIManager.get("TextFieldUI") equals "com.dwc.laf.ui.DwcTextFieldUI".

Run full test suite to confirm no regressions from all prior phases.
  </action>
  <verify>Run `mvn test -f /Users/beff/_lab/dwclaf/pom.xml` -- all tests pass (including new DwcTextFieldUITest and all prior tests, zero failures).</verify>
  <done>DwcTextFieldUITest.java has 10 tests covering per-component instances, opaque=false, border installation, minimum height, hover state, placeholder property, paint smoke tests (normal, placeholder, disabled), and UI class registration. All tests pass.</done>
</task>

</tasks>

<verification>
1. `mvn test -f /Users/beff/_lab/dwclaf/pom.xml` passes all tests (zero failures, zero skipped)
2. DwcTextFieldUI.java exists with paintSafely override (not paint override -- paint is final)
3. DwcTextFieldUI installs MouseListener for hover and FocusListener for focus repaint
4. DwcTextFieldUI paints placeholder text when document is empty
5. DwcTextFieldUI paints focus ring when component has focus
6. DwcTextFieldUI sets opaque=false via LookAndFeel.installProperty
7. DwcTextFieldUI calls super.paintSafely(g) with original Graphics (not g.create())
8. Each JTextField gets its own DwcTextFieldUI instance
</verification>

<success_criteria>
- JTextField paints with rounded background and border from CSS tokens (TF-01)
- JTextField shows visually distinct hover (border color change), focused (border + focus ring), and disabled (reduced opacity) states (TF-02)
- JTextField renders placeholder text in muted color when empty (TF-03)
- JTextField shows focus ring on focus matching DWC input focus style (TF-04)
- All tests pass with zero failures across the entire project
</success_criteria>

<output>
After completion, create `.planning/phases/05-text-input-components/05-02-SUMMARY.md`
</output>
