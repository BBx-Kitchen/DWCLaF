---
phase: 06-selection-components
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/main/java/com/dwc/laf/ui/DwcComboBoxUI.java
  - src/test/java/com/dwc/laf/ui/DwcComboBoxUITest.java
autonomous: true

must_haves:
  truths:
    - "JComboBox paints with styled dropdown arrow (chevron path, not system arrow button)"
    - "JComboBox has rounded border matching DWC input styling (reuses DwcTextFieldBorder)"
    - "JComboBox popup list uses themed selection highlight (primary blue background, white text)"
    - "JComboBox shows visually distinct states: normal, hover (blue border), focused (focus ring), disabled (reduced opacity)"
  artifacts:
    - path: "src/main/java/com/dwc/laf/ui/DwcComboBoxUI.java"
      provides: "Complete ComboBoxUI delegate with arrow button, renderer, hover tracking"
      min_lines: 150
    - path: "src/test/java/com/dwc/laf/ui/DwcComboBoxUITest.java"
      provides: "Tests for ComboBox UI installation and properties"
      min_lines: 60
  key_links:
    - from: "DwcComboBoxUI.installDefaults"
      to: "UIManager ComboBox.* keys"
      via: "UIManager.getColor/getInt for background, borderColor, selectionBackground"
      pattern: "UIManager\\.getColor\\(\"ComboBox\\."
    - from: "DwcComboBoxUI.createArrowButton"
      to: "Custom arrow button inner class"
      via: "Returns DwcComboBoxArrowButton instead of BasicArrowButton"
      pattern: "createArrowButton"
    - from: "DwcComboBoxUI hover tracking"
      to: "DwcTextFieldBorder"
      via: "DwcTextFieldUI.hover client property (same pattern as Phase 5)"
      pattern: "putClientProperty.*DwcTextFieldUI\\.hover"
---

<objective>
Implement DwcComboBoxUI extending BasicComboBoxUI with a custom chevron arrow button, themed popup list renderer, and hover/focus state tracking that reuses the DwcTextFieldBorder from Phase 5.

Purpose: ComboBox is the most complex Phase 6 component, requiring coordination between the field area (styled like a text field), the arrow button (custom painted chevron), and the popup list (themed renderer). This completes all selection form controls.

Output: DwcComboBoxUI.java with inner classes for arrow button and list renderer, plus tests
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-selection-components/06-RESEARCH.md
@.planning/phases/06-selection-components/06-01-SUMMARY.md
@.planning/phases/05-text-input-components/05-02-SUMMARY.md
@src/main/java/com/dwc/laf/ui/DwcTextFieldUI.java
@src/main/java/com/dwc/laf/ui/DwcTextFieldBorder.java
@src/main/java/com/dwc/laf/ui/DwcButtonUI.java
@src/main/java/com/dwc/laf/DwcLookAndFeel.java
@src/main/resources/com/dwc/laf/token-mapping.properties
</context>

<tasks>

<task type="auto">
  <name>Task 1: DwcComboBoxUI delegate with arrow button, renderer, and hover tracking</name>
  <files>
    src/main/java/com/dwc/laf/ui/DwcComboBoxUI.java
  </files>
  <action>
Create `DwcComboBoxUI extends BasicComboBoxUI` with per-component instances (same pattern as DwcButtonUI, DwcTextFieldUI).

**Static factory:**
```java
public static ComponentUI createUI(JComponent c) {
    return new DwcComboBoxUI();
}
```

**Instance fields:** Cache colors/dimensions read from UIManager during installDefaults: `background`, `foreground`, `borderColor`, `hoverBorderColor`, `selectionBackground`, `selectionForeground`, `popupBackground`, `arrowColor`, `arc`, `focusWidth`, `borderWidth`, `disabledOpacity`. Also a `boolean hover` flag and `MouseListener hoverListener`.

**installDefaults():**
1. Call `super.installDefaults()`.
2. `LookAndFeel.installProperty(comboBox, "opaque", false)`.
3. Read all ComboBox.* colors from UIManager and cache.
4. Read Component.focusWidth, Component.borderWidth, ComboBox.arc from UIManager.
5. Read Component.disabledOpacity from UIManager.
6. Install custom renderer: `comboBox.setRenderer(new DwcComboBoxRenderer())`.
7. Note: ComboBox.border is already set to DwcTextFieldBorder in L&F initComboBoxDefaults (Plan 01).

**installListeners():**
1. Call `super.installListeners()`.
2. Create and install a `MouseAdapter` hoverListener on the comboBox that:
   - `mouseEntered`: sets `hover = true`, sets client property `"DwcTextFieldUI.hover"` to `Boolean.TRUE` on comboBox (so DwcTextFieldBorder reads it), calls `comboBox.repaint()`.
   - `mouseExited`: sets `hover = false`, sets client property to `null`, calls `comboBox.repaint()`.

**uninstallListeners():**
1. If hoverListener != null, `comboBox.removeMouseListener(hoverListener)`, set to null.
2. Call `super.uninstallListeners()`.

**createArrowButton():**
Return an instance of inner class `DwcComboBoxArrowButton` (see below).

**paint(Graphics g, JComponent c):**
1. Get `Graphics2D g2 = (Graphics2D) g.create()` in try-finally.
2. Read component bounds (0, 0, c.getWidth(), c.getHeight()).
3. Compute paint area inside focus ring: `float px = focusWidth`, `py = focusWidth`, `pw = width - focusWidth*2`, `ph = height - focusWidth*2`.
4. If disabled, apply `StateColorResolver.paintWithOpacity(g2, disabledOpacity)`.
5. Paint rounded background: `PaintUtils.paintRoundedBackground(g2, px, py, pw, ph, arc, background)`.
6. Border painting is handled by DwcTextFieldBorder (installed as ComboBox.border), so do NOT paint border here.
7. Call `super.paint(g2, c)` to let BasicComboBoxUI paint the current value text/icon.
8. If focused and enabled: `FocusRingPainter.paintFocusRing(g2, px, py, pw, ph, arc, focusWidth, UIManager.getColor("Component.focusRingColor"))`.
9. `g2.dispose()`.

Wait -- `BasicComboBoxUI.paint()` calls `paintCurrentValueBackground()` and then `paintCurrentValue()`. We should override `paintCurrentValueBackground` to be a no-op (since we paint the background ourselves in our paint method), and let `paintCurrentValue` handle text rendering normally.

Revised approach: Override `paintCurrentValueBackground(Graphics g, Rectangle bounds, boolean hasFocus)` as a no-op (empty method body). The background is painted in the `paint()` method above. The border is painted by DwcTextFieldBorder.

For `paint(Graphics g, JComponent c)`: The basic approach is:
1. Paint background (rounded rect).
2. Call `super.paint(g, c)` which paints current value text via paintCurrentValue.
3. Paint focus ring if focused.

Actually, to avoid complexity, let BasicComboBoxUI handle most painting and just override what's needed:

SIMPLIFIED APPROACH:
- Do NOT override `paint()`. Let `BasicComboBoxUI.paint()` handle the flow (it calls paintCurrentValueBackground + paintCurrentValue).
- Override `paintCurrentValueBackground(Graphics g, Rectangle bounds, boolean hasFocus)` to paint the rounded background for the entire combobox (not just the value area). Use full component dimensions (0, 0, comboBox.getWidth(), comboBox.getHeight()), adjusted for focus width.
- Override `paintCurrentValue(Graphics g, Rectangle bounds, boolean hasFocus)` to let super handle it but ensure the text color is correct (read from UIManager).
- The border is handled by DwcTextFieldBorder.
- Focus ring: paint in `paintCurrentValueBackground` since that's called first.

Wait, painting focus ring in paintCurrentValueBackground is wrong ordering (should be on top). Better: Override paint():

FINAL APPROACH:
```java
@Override
public void paint(Graphics g, JComponent c) {
    Graphics2D g2 = (Graphics2D) g.create();
    try {
        float px = focusWidth;
        float py = focusWidth;
        float pw = c.getWidth() - focusWidth * 2f;
        float ph = c.getHeight() - focusWidth * 2f;

        if (!c.isEnabled()) {
            StateColorResolver.paintWithOpacity(g2, disabledOpacity);
        }

        // Paint rounded background
        PaintUtils.paintRoundedBackground(g2, px, py, pw, ph, arc, background);

        // Let BasicComboBoxUI paint current value (text/icon)
        // This calls paintCurrentValue which renders the selected item text
        super.paint(g2, c);

        // Paint focus ring on top
        if (comboBox.hasFocus() && comboBox.isEnabled()) {
            FocusRingPainter.paintFocusRing(g2, px, py, pw, ph, arc,
                focusWidth, UIManager.getColor("Component.focusRingColor"));
        }
    } finally {
        g2.dispose();
    }
}

@Override
public void paintCurrentValueBackground(Graphics g, Rectangle bounds, boolean hasFocus) {
    // No-op: background painted in paint() method above
}
```

**getMinimumSize / getPreferredSize:** Override `getMinimumSize` to enforce minimum height of 36px (same as TextField). In `getPreferredSize`, call super and ensure height >= 36.

**Inner class DwcComboBoxArrowButton (extends JButton):**
```java
private static class DwcComboBoxArrowButton extends JButton {
    DwcComboBoxArrowButton() {
        setName("ComboBox.arrowButton");
        setRequestFocusEnabled(false);
        setFocusable(false);
        setOpaque(false);
        setBorder(BorderFactory.createEmptyBorder());
        setContentAreaFilled(false);
    }

    @Override
    public Dimension getPreferredSize() {
        return new Dimension(32, 32);
    }

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g.create();
        try {
            Object[] saved = PaintUtils.setupPaintingHints(g2);
            Color arrowColor = UIManager.getColor("ComboBox.buttonArrowColor");
            if (arrowColor == null) arrowColor = Color.DARK_GRAY;
            g2.setColor(arrowColor);

            int w = getWidth();
            int h = getHeight();
            // Chevron arrow (downward-pointing)
            float arrowSize = 8f;
            float cx = w / 2f;
            float cy = h / 2f;
            Path2D.Float arrow = new Path2D.Float();
            arrow.moveTo(cx - arrowSize / 2, cy - arrowSize / 4);
            arrow.lineTo(cx, cy + arrowSize / 4);
            arrow.lineTo(cx + arrowSize / 2, cy - arrowSize / 4);
            g2.setStroke(new BasicStroke(1.5f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
            g2.draw(arrow);

            PaintUtils.restorePaintingHints(g2, saved);
        } finally {
            g2.dispose();
        }
    }
}
```

**Inner class DwcComboBoxRenderer (extends DefaultListCellRenderer):**
```java
private static class DwcComboBoxRenderer extends DefaultListCellRenderer {
    @Override
    public Component getListCellRendererComponent(JList<?> list, Object value,
            int index, boolean isSelected, boolean cellHasFocus) {
        JLabel label = (JLabel) super.getListCellRendererComponent(
                list, value, index, isSelected, cellHasFocus);

        if (isSelected) {
            Color selBg = UIManager.getColor("ComboBox.selectionBackground");
            Color selFg = UIManager.getColor("ComboBox.selectionForeground");
            label.setBackground(selBg != null ? selBg : list.getSelectionBackground());
            label.setForeground(selFg != null ? selFg : list.getSelectionForeground());
        } else {
            Color popBg = UIManager.getColor("ComboBox.popupBackground");
            Color fg = UIManager.getColor("ComboBox.foreground");
            label.setBackground(popBg != null ? popBg : list.getBackground());
            label.setForeground(fg != null ? fg : list.getForeground());
        }

        // Padding for list items
        label.setBorder(BorderFactory.createEmptyBorder(4, 8, 4, 8));
        return label;
    }
}
```

Import all necessary classes: PaintUtils, FocusRingPainter, StateColorResolver from `com.dwc.laf.painting`, and standard AWT/Swing imports (Graphics2D, Path2D, BasicStroke, Color, Dimension, Rectangle, etc.).
  </action>
  <verify>Run `mvn compile -q` to confirm the class compiles without errors.</verify>
  <done>DwcComboBoxUI extends BasicComboBoxUI with custom chevron arrow button, themed popup renderer (DWC selection colors), hover tracking via DwcTextFieldUI.hover client property, rounded background via PaintUtils, focus ring via FocusRingPainter, and disabled opacity. Reuses DwcTextFieldBorder for border painting.</done>
</task>

<task type="auto">
  <name>Task 2: DwcComboBoxUI tests</name>
  <files>
    src/test/java/com/dwc/laf/ui/DwcComboBoxUITest.java
  </files>
  <action>
Create test class `DwcComboBoxUITest` following the same pattern as DwcButtonUITest and DwcTextFieldUITest.

**Setup/teardown:**
- `@BeforeEach`: Save current L&F, set DwcLookAndFeel.
- `@AfterEach`: Restore saved L&F.

**Tests:**
1. `createUI_returnsPerComponentInstances` — Two calls to `DwcComboBoxUI.createUI(new JComboBox<>())` return different instances.
2. `comboBox_hasCorrectUI` — `new JComboBox<>()` has `getUI() instanceof DwcComboBoxUI`.
3. `comboBox_isNotOpaque` — `new JComboBox<>().isOpaque()` returns false.
4. `comboBox_hasDwcTextFieldBorder` — `comboBox.getBorder()` is instanceof DwcTextFieldBorder (unwrap from BorderUIResource if needed).
5. `comboBox_hasCustomRenderer` — `comboBox.getRenderer()` is not null and is the DwcComboBoxRenderer (test via class name check since it's a private inner class -- or just verify it's not DefaultListCellRenderer directly).
6. `arrowButton_isCustom` — Reflect or check that the arrow button field in BasicComboBoxUI is not a BasicArrowButton. Access via `comboBox.getComponent(0)` which is typically the arrow button.
7. `paintSmokeTest` — Create a JComboBox with items, set bounds, paint onto a BufferedImage. No exceptions thrown.
8. `paintSmokeTest_withSelectedItem` — Same as above but with a selected item.
9. `preferredSize_hasMinimumHeight` — `comboBox.getPreferredSize().height >= 36`.
10. `comboBox_hoverClientProperty` — Simulate: dispatch MouseEvent.MOUSE_ENTERED, check client property `"DwcTextFieldUI.hover"` is Boolean.TRUE. Dispatch MOUSE_EXITED, check it's null.
  </action>
  <verify>Run `mvn test -q` and confirm ALL tests pass (existing + new). Expected: 0 failures.</verify>
  <done>DwcComboBoxUITest has 10 tests covering per-component instances, correct UI class, opacity, border type, custom renderer, arrow button, paint smoke tests, minimum height, and hover client property. All tests pass.</done>
</task>

</tasks>

<verification>
1. `mvn test -q` — All tests pass (existing + new from Plan 01 + Plan 02)
2. `ls src/main/java/com/dwc/laf/ui/DwcComboBoxUI.java` — File exists
3. JComboBox renders with chevron arrow, not system arrow button
4. Popup list items use DWC selection colors (blue background, white text for selected)
5. ComboBox border is DwcTextFieldBorder (shared with TextField)
</verification>

<success_criteria>
- JComboBox renders with custom DwcComboBoxUI (chevron arrow, rounded border)
- Popup list has themed selection highlight colors from CSS tokens
- ComboBox shows 4 distinct visual states (normal, hover, focused, disabled)
- Hover state tracked via same client property pattern as Phase 5 TextField
- All tests pass including paint smoke tests
</success_criteria>

<output>
After completion, create `.planning/phases/06-selection-components/06-02-SUMMARY.md`
</output>
