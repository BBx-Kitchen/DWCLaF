---
phase: 12-more-rendering-detail-to-match-dwc
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/com/dwc/laf/ui/DwcProgressBarUI.java
  - src/main/java/com/dwc/laf/painting/PaintUtils.java
autonomous: true

must_haves:
  truths:
    - "ProgressBar percentage text is white on dark fill colors (primary blue, danger red, success green)"
    - "ProgressBar percentage text is dark/black on light fill colors (warning amber)"
    - "Text color switches dynamically based on whether fill covers more than half the bar"
    - "1px borders on TextField and ComboBox appear crisp and sharp, not fuzzy or doubled"
  artifacts:
    - path: "src/main/java/com/dwc/laf/ui/DwcProgressBarUI.java"
      provides: "Contrast-aware text color selection using W3C relative luminance"
      contains: "linearize"
    - path: "src/main/java/com/dwc/laf/painting/PaintUtils.java"
      provides: "Pixel-boundary-aware outline painting for maximum border crispness"
      contains: "paintOutline"
  key_links:
    - from: "DwcProgressBarUI.paintString"
      to: "contrastTextColor method"
      via: "luminance calculation determines black or white text"
      pattern: "contrastTextColor"
    - from: "PaintUtils.paintOutline"
      to: "DwcTextFieldBorder and DwcButtonBorder"
      via: "even-odd fill with integer-snapped coordinates"
      pattern: "paintOutline"
---

<objective>
Add contrast-aware text color for ProgressBar percentage display and improve border crispness for 1px outlines across all components.

Purpose: DWC dynamically switches the ProgressBar percentage text between dark and white based on the fill color's luminance. The current Swing implementation uses a static foreground color regardless of fill. Additionally, 1px borders on TextField and ComboBox can appear soft or fuzzy due to subpixel anti-aliasing -- ensuring integer pixel boundaries in the outline painting produces maximum crispness.

Output: Updated DwcProgressBarUI with luminance-based text color, refined PaintUtils for crisp border rendering
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-more-rendering-detail-to-match-dwc/12-RESEARCH.md
@src/main/java/com/dwc/laf/ui/DwcProgressBarUI.java
@src/main/java/com/dwc/laf/painting/PaintUtils.java
@src/main/java/com/dwc/laf/ui/DwcTextFieldBorder.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement contrast-aware text color in DwcProgressBarUI</name>
  <files>src/main/java/com/dwc/laf/ui/DwcProgressBarUI.java</files>
  <action>
Modify the `paintString` method in `DwcProgressBarUI` to dynamically select text color (black or white) based on the dominant background color's luminance:

1. Add a private `contrastTextColor(Color bg)` method that computes relative luminance using the W3C formula:
   - Linearize each sRGB channel: if value <= 0.04045, divide by 12.92; else apply `((v + 0.055) / 1.055) ^ 2.4`
   - Compute luminance: `L = 0.2126 * R + 0.7152 * G + 0.0722 * B`
   - Return `Color.BLACK` if luminance > 0.4, else `Color.WHITE`
   - The threshold of 0.4 ensures white text on medium-dark fills (like primary blue L~0.13, danger red, success green) and black text on light fills (like warning amber L~0.74)

2. Add a private `linearize(double srgb)` helper for the sRGB linearization step.

3. In `paintString`, instead of `g2.setColor(pb.getForeground())`:
   - Determine whether the fill or track is the dominant area: if the bar is horizontal, compare `amountFull > width / 2`; if vertical, compare `amountFull > height / 2`.
   - If fill is dominant, use `contrastTextColor(fillColor)` where fillColor comes from `resolveVariantColor(pb)`.
   - If track is dominant, use `contrastTextColor(background)` where background is the track color.
   - Set this computed color on g2 before drawing the string.

4. Import `java.awt.Color` is already present. No new imports needed.

This approach uses a single text color for the entire string (not split at fill boundary) for simplicity. The color is based on whichever area (fill or track) dominates the bar, giving correct visual contrast for the majority of the text.
  </action>
  <verify>
Run `mvn compile -f /Users/beff/_lab/dwclaf/pom.xml` to confirm compilation. Verify the file contains `contrastTextColor`, `linearize`, and the luminance formula constants (0.2126, 0.7152, 0.0722).
  </verify>
  <done>
ProgressBar percentage text dynamically switches between black and white based on fill color luminance. Dark fills (primary blue, danger red, success green) get white text. Light fills (warning amber, track gray) get black text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve border crispness in PaintUtils.paintOutline</name>
  <files>src/main/java/com/dwc/laf/painting/PaintUtils.java</files>
  <action>
Audit and refine `PaintUtils.paintOutline()` for maximum 1px border crispness:

1. The existing even-odd fill approach is correct (fills the mathematical area between outer and inner rounded rects). The key refinement is ensuring coordinates are on integer pixel boundaries to avoid subpixel anti-aliasing softness.

2. In `paintOutline()`, before creating the path, snap the input coordinates to integer boundaries:
   - `x = Math.round(x)`, `y = Math.round(y)`, `w = Math.round(w)`, `h = Math.round(h)`
   - `lineWidth = Math.max(1, Math.round(lineWidth))` -- ensure at least 1px
   - This prevents fractional coordinates from causing the 1px outline to spread across 2 device pixels.

3. The `VALUE_STROKE_NORMALIZE` hint (set by `setupPaintingHints`) helps with stroke-based rendering but does not directly affect filled shapes. For the even-odd fill technique, integer coordinates are the primary factor for crispness. The existing hint is still beneficial for any other stroke-based rendering.

4. Do NOT change `VALUE_ANTIALIAS_ON` -- it is needed for smooth rounded corners. The integer snapping ensures straight border edges are crisp while corners remain smooth.

5. This change affects all components that use `paintOutline`: DwcButtonBorder, DwcTextFieldBorder, DwcToolTipBorder. All will benefit from crisper 1px borders.

The change is small but impactful: snapping to integer boundaries before constructing the path ensures the 1px border lands cleanly on the pixel grid across all scale factors.
  </action>
  <verify>
Run `mvn compile -f /Users/beff/_lab/dwclaf/pom.xml` to confirm compilation. Run `mvn test -f /Users/beff/_lab/dwclaf/pom.xml` to verify no tests break from the coordinate snapping.
  </verify>
  <done>
PaintUtils.paintOutline snaps coordinates to integer pixel boundaries before constructing the even-odd fill path, producing maximum crispness for all 1px borders across TextField, ComboBox, Button, and ToolTip components.
  </done>
</task>

</tasks>

<verification>
1. `mvn compile -f /Users/beff/_lab/dwclaf/pom.xml` succeeds
2. `mvn test -f /Users/beff/_lab/dwclaf/pom.xml` passes all tests
3. DwcProgressBarUI contains `contrastTextColor` and `linearize` methods
4. PaintUtils.paintOutline snaps coordinates to integers via Math.round
</verification>

<success_criteria>
ProgressBar text color adapts to fill color luminance (white on dark fills, black on light fills). 1px borders render crisply without subpixel softness. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/12-more-rendering-detail-to-match-dwc/12-02-SUMMARY.md`
</output>
